#include "../advent_of_code.hpp"

#include <set>
#include <stack>
#include <unordered_map>
#include <queue>

// https://adventofcode.com/2015/day/19

namespace {
    struct WordRange;

    /** A rule, with the string it replaces and the string it replaces with */
    struct Rule {
        std::string from;
        std::string to;

        explicit Rule(const std::string & str) {
            StringSplitter splitter { str, ' ' };
            from = splitter();
            splitter();
            to = splitter();
        }
        
        Rule(std::string from, std::string to) : from(from), to(to) {}

        friend std::ostream & operator<<(std::ostream & stream, const Rule & rule) {
            return stream << rule.from << " -> " << rule.to;
        }

        /**
         * Build the range of words that can be reached from word with one
         * application of this rule
         */
        WordRange map_to_constructible(const std::string & word) const;
    };

    /** Iterator on words generated by a rule */
    struct RuleIterator {
        const std::string & word;
        const Rule & rule;
        std::optional<std::string> current;
        size_t cursor;

        /** Build begin() */
        RuleIterator(const std::string & word, const Rule & rule) :
        word(word), rule(rule) {
            cursor = 0;
            // Begin must point on first element
            operator++();
        }

        /** Build end() */
        RuleIterator(const std::string & word, const Rule & rule, bool) :
        word(word), rule(rule) {
            cursor = 0;
            current = std::nullopt;
        }

        RuleIterator & operator++() {
            const auto new_position = word.find(rule.from, cursor);

            if (new_position == std::string::npos) {
                // Build end
                current = std::nullopt;
            } else {
                // Move to new_position
                cursor = new_position + 1;
                current = word.substr(0, new_position) + rule.to + word.substr(new_position + rule.from.length());
            }

            return *this;
        }

        const std::string & operator*() const {
            return current.value();
        }

        bool operator!=(const RuleIterator & other) const {
            return &rule != &other.rule || other.current != current;
        }
    };

    /** A range of word builded by a rule */
    struct WordRange {
        const std::string & word;
        const Rule & rule;

        RuleIterator begin() const { return RuleIterator(word, rule); }
        RuleIterator end()   const { return RuleIterator(word, rule, false); }
    };

    WordRange Rule::map_to_constructible(const std::string & word) const {
        return WordRange { word, *this };
    }

    /** Swap the head and the body of a rule */
    std::vector<Rule> revert_rules(const std::vector<Rule> & rules) {
        std::vector<Rule> retval;
        for (const auto & rule : rules) {
            retval.emplace_back(rule.to, rule.from);
        }
        return retval;
    }
}

namespace {
    [[nodiscard]] size_t find_number_of_buildable_words_from(std::string word, std::vector<Rule> rules) {
        std::set<std::string> words;

        for (const Rule & rule : rules) {
            for (const std::string & word : rule.map_to_constructible(word)) {
                words.insert(word);
            }
        }

        return words.size();
    }

    // Shorter words are greater than longer
    struct ShortestWordsLast {
        bool operator()(const std::string & lhs, const std::string & rhs) const {
            if (lhs.size() < rhs.size()) {
                return false;
            } else if (lhs.size() > rhs.size()) {
                return true;
            } else {
                return lhs < rhs;
            }
        }
    };

    [[nodiscard]] static std::optional<size_t> length_to_build(
        const std::string & initial_word, const std::string & final_word,
        std::vector<Rule> rules) {
        if (initial_word == final_word) return 0;

        // Revert the rule to be able to converge to e instead of diverge to maybe searched
        std::vector<Rule> reversed_rules = revert_rules(rules);

        // Structures
        std::unordered_map<std::string, size_t> steps_to_reach;
        std::priority_queue<std::string, std::vector<std::string>, ShortestWordsLast> wordsToExplore;

        // Base case: the final word (yes)
        steps_to_reach[final_word] = 0;
        wordsToExplore.push(final_word);

        while (!wordsToExplore.empty()) {
            // A new candidate
            const std::string w = wordsToExplore.top();
            const auto my_steps = steps_to_reach[w];
            wordsToExplore.pop();

            // Apply each rule
            for (const Rule & rule : reversed_rules) {
                // Find every possible substitution
                for (const auto & new_word : rule.map_to_constructible(w)) {
                    if (new_word == initial_word) {
                        return my_steps + 1;
                    }

                    const auto itExplored = steps_to_reach.find(new_word);
                    if (itExplored == steps_to_reach.end() || itExplored->second > my_steps + 1) {
                        steps_to_reach[new_word] = my_steps + 1;
                        wordsToExplore.push(new_word);
                    }
                }
            }
        }

        // No more candidate
        return std::nullopt;
    }
}

Output day_2015_19(const std::vector<std::string> & lines, const DayExtraInfo &) {
    const auto [rules, initial_string] = [&]() {
        std::vector<Rule> rules;
        std::string str;

        bool empty_line = false;
        for (const auto & line : lines) {
            if (line == "") {
                empty_line = true;
            } else if (empty_line) {
                str = line;
            } else {
                rules.emplace_back(line);
            }
        }

        return std::pair<std::vector<Rule>, std::string>(rules, str);
    }();

    const auto nb_generated_from_input = find_number_of_buildable_words_from(initial_string, rules);
    const auto path_length_from_e = length_to_build("e", initial_string, rules).value();

    return Output(nb_generated_from_input, path_length_from_e);
}
